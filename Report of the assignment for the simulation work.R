# Victor Malheiro 201406480

##### 1st Part of the Assignment


## Rejection Method with Gamma dist.(3/2,1)

reject.gamma <- function(nvals)
{
  x.accept <- NULL
  u.accept <- NULL
  nx <- 0
  x.rejected <- NULL
  u.rejected <- NULL
  nrejected <- 0
  while(nx < nvals) 
    {
    Y <- runif(1)
    Z <- runif(1)
    U <- runif(1,0,(3*(sqrt(3/(2*pi*exp(1))))*(2/3)*(exp(-((2/3)*Z)))))
    if(U <= ((2/sqrt(pi))*(Y^(1/2))*(exp(-Y)))) 
       {
      nx <- nx + 1
      x.accept[nx] <- Y
      u.accept[nx] <- U
       } 
      else 
        {
      nrejected <- nrejected + 1
      x.rejected[nrejected] <- Y
      u.rejected[nrejected] <- U
        }
     }
  plot(x.accept,u.accept,pch=20,col="green",xlab="x",ylab="f(x)",main=paste("Gamma(3/2 ,1)\nPoints generated by the Rejection\nMethod with n = ",nvals))
  lines(x.rejected,u.rejected,pch=20,col="red",type="p")
	x.val <- seq(0,1,0.01)
	lines(x.val,dgamma(x.val,(3/2),1),col="blue")
  return(x.accept)
}

nvals <- 1000
XX <- reject.gamma(nvals)

hist(XX,breaks=20,prob=TRUE,xlim=c(0,1),ylim=c(0,2),main=paste("Gamma(3/2,1) by the\nRejection Method n = ",nvals))
x.val <- seq(0,1,0.1)
lines(x.val,dgamma(x.val,(3/2),1),col="blue")

## QQ plot

quantiles.pop <- qgamma(seq(1/nvals, 1, by = 1/nvals),shape = 7)
qq <- cbind(sort(XX), quantiles.pop)
plot(qq, pch=".", xlim=c(0,1), ylim=c(0,15), xlab="X", ylab="Y", main=paste("QQ plot for n =",nvals))
abline(2.8,7.4,col="green")



##### 2nd Part of the Assignment
## Monte Carlo Method

# simulation of a point of bivariate normal distribution
polar.normal <- function(nvals)
{
  x <- NULL
  nx <- 0
  while(nx < nvals) {
    U1 <- runif(1)
    U2 <- runif(1)
    V1 <- 2*U1-1
    V2 <- 2*U2-1
    W = V1^2 + V2^2
    if( W <= 1) {
      C <- sqrt(-2*log(W)/W)
      x[nx+1] <- C * V1
      x[nx+2] <- C * V2
      nx <- nx + 2
    }
  }
  x
}


rbinorm <- function(mu,vmat)
{
  Z <- polar.normal(2)
  S <- t(chol(vmat))
  X <- mu + S %*% Z
  X
}


rbinorm.n <- function(nvals,mu,vmat)
{
  X1 <- NULL
  X2 <- NULL
  for(i in 1:nvals) {
    X <- rbinorm(mu,vmat)
    X1[i] <- X[1,1]
    X2[i] <- X[2,1]
  }
  cbind(X1,X2)
}


n <- 1000
mu <- c(0,0)
vmat <- matrix(c(1,0.75,0.75,1),2,2)
xy <- rbinorm.n(n,mu,vmat)


plot(xy, pch=".", xlim=c(-3,3), ylim=c(-3,3), xlab="X", ylab="Y", main=paste("Bivariate normal distribution\nn=",n))
abline(h=0,col="blue")
abline(v=0,col="blue")


# computing of the probability

gera.binorm <- function(nvals,ro)
{
  x <- polar.normal(nvals)
  yy <- polar.normal(nvals)
  y <- ro*x + yy*sqrt(1-ro^2)
  return(cbind(x,y))
}


mean.estimated <- function(nvals,ro) {
  IA.xy <- gera.binorm(nvals,ro)
  X <- IA.xy[,1]
  Y <- IA.xy[,2]
  aux <- (X^3)+(2*(Y^2)) > 3
  return(sum(aux)/nvals)
}


monte.carlo <- function(nreps,nvals,ro) {
  estimativas <- NULL
  for (i in 1:nreps){
    estimativas[i] <- mean.estimated(nvals,ro)
  }
  return(estimativas)
}

ro <- 0.75
nreps <- 400
nvals <- 1000
simvalues <- monte.carlo(nreps,nvals,ro)
hist(simvalues, xlim=c(min(simvalues)-0.01,max(simvalues)+0.01), main=paste("Estimation of P(X^3+2Y^2>3)\n(",nreps,"estimations with n =",nvals,")"))
